#!/usr/bin/env node

var cli = require('commander'),
    config = require('./config'),
    async = require('async'),
    logger = require('./log');

var db = require(config.database.type);
var admin_paths = config.api.administration_paths;

db.init(function(err) {
    if (err) {
        logger.error(err);
    }
});

var administrationPath = function(path, callback) {
    var is_admin_path = false;

    async.forEachOf(admin_paths, function(admin_path, key, task_callback) {
        if (path === admin_path  && ! is_admin_path) {
            is_admin_path = true;
        }
        task_callback();
    }, function() {
        return callback(is_admin_path);
    });
}

cli
    .description('Configuration tool for accounting proxy.')
    .version('0.0.1');


/**
 * Add new service; map the public path with the endpoint url.
 */
cli
    .command('addService [publicPath] [URL] [appId]')
    .description('Add new service to proxy database.')
    .action(function(publicPath, url, appId) {
        administrationPath(publicPath, function(adminPath) {
            if (adminPath) {
                logger.error(publicPath + ' is a reserved path.')
            } else {
                if (/\/((\w+)\/?)+$/.test(publicPath)) {
                    if (/^(http|https):\/\/[^ "]+$/.test(url)) {
                        if (appId !== undefined) {
                            db.newService(publicPath, url, appId, function(err) {
                                if (err) {
                                    logger.error(err);
                                } else {
                                    logger.info('Service successfully added.');
                                }
                            });
                        } else {
                            logger.error('Undefined appId');
                        }
                    } else {
                        logger.error('Invalid url. Format: "http|https://host:port/path"');
                    }
                }
                else {
                    logger.error('Invalid public path. Format: "/publicPath"');
                }
            }
        });
    });

/**
 * Return the enpoint url associated with the public path passed.
 */
cli
    .command('getService [publicPath]')
    .description('Get service\'s information.')
    .action(function(publicPath) {
        if (/\/((\w+)\/?)+$/.test(publicPath)){
            db.getService(publicPath, function(err, service) {
                if(err) {
                    console.log(err);
                } else if (service === null) {
                    console.log('No service avaliable for path: ' + publicPath);
                } else {
                    console.log('URL: ' + service.url + ' APP-ID: ' + service.appId);
                }
            });
        } else {
            logger.error('Invalid public path. Format: "/publicPath"');
        } 
    });

/**
 * Display all the registered services (public path and url).
 */
cli
    .command('getAllServices')
    .description('Display all the registered services (public path and url).')
    .action(function() {
        db.getAllServices(function(err, services) {
            if (err) {
                logger.error(err);
            } else if (services.length === 0) {
                console.log('No service registered. Use: "addService "publicPath" "URL" to register a new service.')
            } else {
                for (var i = 0; i < services.length; i++) {
                    console.log('PUBLIC PATH: ' + services[i].publicPath + ' URL: ' + services[i].url + ' APP-ID: ' + services[i].appId);
                }
            }
        });
    });


/**
 * Delete the service associated with the public path passed.
 */
cli
    .command('deleteService [publicPath]')
    .description('Delete a service from proxy database.')
    .action(function(path) {
        if (/\/((\w+)\/?)+$/.test(path)) {
            db.deleteService(path, function(err) {
                if (err) {
                    logger.error(err);
                } else {
                    logger.info('Service ' + path + ' deleted.')
                }
            });
        } else {
            logger.error('Invalid public path. Format: "/publicPath"');
        }
    });

/**
 * Add a new administrator.
 */
cli
    .command('addAdmin [admin]')
    .description('Add a new administrator.')
    .action(function(admin) {
        if (admin === undefined) {
            logger.error('Usage: addAdmin "admin"');
        } else {
            db.addAdmin(admin, function(err) {
                if (err) {
                    logger.error(err);
                } else {
                    logger.info('Added admin: ' + admin);
                }
            });
        }
    });

/**
 * Delete the administrator specified.
 */
cli
    .command('deleteAdmin [admin]')
    .description('Delete the specified admin.')
    .action(function(admin) {
        if (admin == undefined) {
            logger.error('Usage: deleteAdmin "admin"');
        } else {
            db.deleteAdmin(admin, function(err) {
                if (err) {
                    logger.error(err);
                } else {
                    logger.info('Deleted admin: ' + admin);
                }
            });
        }
    });

/**
 * Bind the specified administrator to the service specified by its public path.
 */
cli
    .command('bindAdmin [admin] [publicPath]')
    .description('Add a new administrator for the service specified by the public path.')
    .action(function(admin, publicPath) {
        if (admin === undefined) {
            logger.error('Usage: addAdmin "admin" "publicPath"');
        } else if (/\/((\w+)\/?)+$/.test(publicPath)) {
            db.bindAdmin(admin, publicPath, function(err) {
                if (err) {
                    logger.error(err);
                } else {
                    logger.info('Admin ' + admin + ' added to service ' + publicPath);
                }
            });
        } else {
            logger.error('Invalid public path. Format: "/publicPath"');
        }
    });

/**
 * Unbind the specified administrator from the specified service identified by its public path.
 */
cli
    .command('unbindAdmin [admin] [publicPath]')
    .description('Delete the specified administrator for the specified service by its public path.')
    .action(function(admin, publicPath) {
        if (admin === undefined) {
            logger.error('Usage: addAdmin "admin" "publicPath"');
        } else if (/\/((\w+)\/?)+$/.test(publicPath)) {
            db.unbindAdmin(admin, publicPath, function(err) {
                if (err) {
                    logger.error(err);
                } else {
                    logger.info('Administrator ' + admin + ' delete from service ' + publicPath);
                }
            });
        } else { 
            logger.error('Invalid public path. Format: "/publicPath"');
        }
    });

/**
 * Display all the administrator for the specified service.
 */
cli
    .command('getAdmins [publicPath]')
    .description('Display all the administrators for the specified service.')
    .action(function(publicPath) {
        if (/\/((\w+)\/?)+$/.test(publicPath)) {
            db.getAdmins(publicPath, function(err, admins) {
                if (err) {
                    logger.error(err);
                } else if (admins.length === 0) {
                    logger.info('No administrators available for the service ' + publicPath);
                } else {
                    console.log('SERVICE: ' + publicPath + ' ADMINISTRATORS:');
                    for (var i = 0; i < admins.length; i++) {
                        console.log('   ' + admins[i]);
                    }
                }
            });
        } else { 
            logger.error('Invalid public path. Format: "/publicPath"');
        }
    });

cli.parse(process.argv);